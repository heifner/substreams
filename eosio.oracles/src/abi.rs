// Generated by antelope-abi2rs 0.4.1 - eosio::abi/1.1

use serde::{Deserialize, Deserializer, Serialize};

type Asset = String;
type Name = String;
type Bool = bool;
type Checksum256 = String;
type Symbol = String;
type SymbolCode = String;
type TimePoint = String;
type TimePointSec = String;
type Int64 = i64;
type Uint16 = u16;
type Uint32 = u32;
type Uint64 = u64;
type Float64 = String;

fn str_or_i64<'de, D>(deserializer: D) -> Result<i64, D::Error>
where
    D: Deserializer<'de>,
{
    #[derive(Deserialize)]
    #[serde(untagged)]
    enum StrOrI64<'a> {
        Str(&'a str),
        I64(i64),
    }

    Ok(match StrOrI64::deserialize(deserializer)? {
        StrOrI64::Str(v) => v
            .parse::<i64>()
            .map_err(|_| serde::de::Error::custom("failed to parse i64 number"))?,
        StrOrI64::I64(v) => v,
    })
}

fn str_or_u64<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: Deserializer<'de>,
{
    #[derive(Deserialize)]
    #[serde(untagged)]
    enum StrOrU64<'a> {
        Str(&'a str),
        U64(u64),
    }

    Ok(match StrOrU64::deserialize(deserializer)? {
        StrOrU64::Str(v) => v
            .parse::<u64>()
            .map_err(|_| serde::de::Error::custom("failed to parse u64 number"))?,
        StrOrU64::U64(v) => v,
    })
}

macro_rules! impl_try_from_str {
    ($type:ty) => {
        impl TryFrom<&str> for $type {
            type Error = serde_json::Error;
            #[inline]
            fn try_from(str: &str) -> Result<Self, Self::Error> {
                serde_json::from_str(str)
            }
        }
    };
}
type AssetType = Uint16;

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Abusers {
    pub name: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub votes: Uint64,
}
impl_try_from_str!(Abusers);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Addcustodian {
    pub name: Name,
}
impl_try_from_str!(Addcustodian);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Bars {
    #[serde(deserialize_with = "str_or_u64")]
    pub id: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub high: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub low: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub median: Uint64,
    pub timestamp: TimePoint,
}
impl_try_from_str!(Bars);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Cancelbounty {
    pub name: Name,
    pub reason: String,
}
impl_try_from_str!(Cancelbounty);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Claim {
    pub owner: Name,
}
impl_try_from_str!(Claim);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Clear {
    pub pair: Name,
}
impl_try_from_str!(Clear);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Configure {
    pub g: Globalinput,
}
impl_try_from_str!(Configure);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Custodians {
    pub name: Name,
}
impl_try_from_str!(Custodians);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Datapoints {
    #[serde(deserialize_with = "str_or_u64")]
    pub id: Uint64,
    pub owner: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub value: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub median: Uint64,
    pub timestamp: TimePoint,
}
impl_try_from_str!(Datapoints);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Delcustodian {
    pub name: Name,
}
impl_try_from_str!(Delcustodian);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Deletepair {
    pub name: Name,
    pub reason: String,
}
impl_try_from_str!(Deletepair);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Donations {
    #[serde(deserialize_with = "str_or_u64")]
    pub id: Uint64,
    pub donator: Name,
    pub pair: Name,
    pub timestamp: TimePoint,
    pub amount: Asset,
}
impl_try_from_str!(Donations);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Editbounty {
    pub name: Name,
    pub pair: Pairinput,
}
impl_try_from_str!(Editbounty);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Editpair {
    pub pair: Pairs,
}
impl_try_from_str!(Editpair);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Forfeithash {
    pub owner: Name,
}
impl_try_from_str!(Forfeithash);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Global {
    #[serde(deserialize_with = "str_or_u64")]
    pub id: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub total_datapoints_count: Uint64,
    pub total_claimed: Asset,
    #[serde(deserialize_with = "str_or_u64")]
    pub datapoints_per_instrument: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub bars_per_instrument: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub vote_interval: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub write_cooldown: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub approver_threshold: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub approving_oracles_threshold: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub approving_custodians_threshold: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub minimum_rank: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub paid: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub min_bounty_delay: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub new_bounty_delay: Uint64,
}
impl_try_from_str!(Global);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Globalinput {
    #[serde(deserialize_with = "str_or_u64")]
    pub datapoints_per_instrument: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub bars_per_instrument: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub vote_interval: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub write_cooldown: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub approver_threshold: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub approving_oracles_threshold: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub approving_custodians_threshold: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub minimum_rank: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub paid: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub min_bounty_delay: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub new_bounty_delay: Uint64,
}
impl_try_from_str!(Globalinput);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Hashes {
    #[serde(deserialize_with = "str_or_u64")]
    pub id: Uint64,
    pub owner: Name,
    pub multiparty: Checksum256,
    pub hash: Checksum256,
    pub reveal: String,
    pub timestamp: TimePoint,
}
impl_try_from_str!(Hashes);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Migratedata {
}
impl_try_from_str!(Migratedata);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Networks {
    pub name: Name,
}
impl_try_from_str!(Networks);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Newbounty {
    pub proposer: Name,
    pub pair: Pairinput,
}
impl_try_from_str!(Newbounty);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Oglobal {
    #[serde(deserialize_with = "str_or_u64")]
    pub id: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub total_datapoints_count: Uint64,
}
impl_try_from_str!(Oglobal);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Pairinput {
    pub name: Name,
    pub base_symbol: Symbol,
    pub base_type: AssetType,
    pub base_contract: Name,
    pub quote_symbol: Symbol,
    pub quote_type: AssetType,
    pub quote_contract: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub quoted_precision: Uint64,
}
impl_try_from_str!(Pairinput);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Pairs {
    pub active: Bool,
    pub bounty_awarded: Bool,
    pub bounty_edited_by_custodians: Bool,
    pub proposer: Name,
    pub name: Name,
    pub bounty_amount: Asset,
    pub approving_custodians: Vec<Name>,
    pub approving_oracles: Vec<Name>,
    pub base_symbol: Symbol,
    pub base_type: AssetType,
    pub base_contract: Name,
    pub quote_symbol: Symbol,
    pub quote_type: AssetType,
    pub quote_contract: Name,
    #[serde(deserialize_with = "str_or_u64")]
    pub quoted_precision: Uint64,
}
impl_try_from_str!(Pairs);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Price {
    #[serde(deserialize_with = "str_or_u64")]
    pub id: Uint64,
    pub contract: Name,
    pub coin: SymbolCode,
    pub precision: Uint32,
    #[serde(deserialize_with = "str_or_u64")]
    pub acc_price: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub last_price: Uint64,
    #[serde(deserialize_with = "str_or_u64")]
    pub avg_price: Uint64,
    pub last_update: TimePointSec,
}
impl_try_from_str!(Price);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Quote {
    #[serde(deserialize_with = "str_or_u64")]
    pub value: Uint64,
    pub pair: Name,
}
impl_try_from_str!(Quote);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Reguser {
    pub owner: Name,
}
impl_try_from_str!(Reguser);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Stats {
    pub owner: Name,
    pub timestamp: TimePoint,
    #[serde(deserialize_with = "str_or_u64")]
    pub count: Uint64,
    pub last_claim: TimePoint,
    pub balance: Asset,
}
impl_try_from_str!(Stats);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Unvotebounty {
    pub owner: Name,
    pub bounty: Name,
}
impl_try_from_str!(Unvotebounty);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Updateusers {
}
impl_try_from_str!(Updateusers);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Users {
    pub name: Name,
    pub contribution: Asset,
    #[serde(deserialize_with = "str_or_u64")]
    pub score: Uint64,
    pub creation_timestamp: TimePoint,
}
impl_try_from_str!(Users);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Voteabuser {
    pub owner: Name,
    pub abuser: Name,
}
impl_try_from_str!(Voteabuser);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Votebounty {
    pub owner: Name,
    pub bounty: Name,
}
impl_try_from_str!(Votebounty);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct VoterInfo {
    pub owner: Name,
    pub proxy: Name,
    pub producers: Vec<Name>,
    #[serde(deserialize_with = "str_or_i64")]
    pub staked: Int64,
    pub last_vote_weight: Float64,
    pub proxied_vote_weight: Float64,
    pub is_proxy: Bool,
    pub flags1: Uint32,
    pub reserved2: Uint32,
    pub reserved3: Asset,
}
impl_try_from_str!(VoterInfo);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Write {
    pub owner: Name,
    pub quotes: Vec<Quote>,
}
impl_try_from_str!(Write);

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Writehash {
    pub owner: Name,
    pub hash: Checksum256,
    pub reveal: String,
}
impl_try_from_str!(Writehash);

