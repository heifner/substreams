// Generated by antelope-abi2rs 0.2.0 - eosio::abi/1.2

use serde::{Deserialize, Serialize};

type Asset = String;
type Name = String;
type PublicKey = String;
type Uint16 = u16;
type Uint32 = u32;


macro_rules! impl_try_from_str {
    ($type:ty) => {
        impl TryFrom<&str> for $type {
            type Error = serde_json::Error;
            #[inline]
            fn try_from(str: &str) -> Result<Self, Self::Error> {
                serde_json::from_str(str)
            }
        }
    };
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct Authority {
    pub threshold: Uint32,
    pub keys: Vec<KeyWeight>,
    pub accounts: Vec<PermissionLevelWeight>,
    pub waits: Vec<WaitWeight>,
}
impl_try_from_str!(Authority);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct Buyram {
    pub payer: Name,
    pub receiver: Name,
    pub quant: Asset,
}
impl_try_from_str!(Buyram);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct Buyrambytes {
    pub payer: Name,
    pub receiver: Name,
    pub bytes: Uint32,
}
impl_try_from_str!(Buyrambytes);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct KeyWeight {
    pub key: PublicKey,
    pub weight: Uint16,
}
impl_try_from_str!(KeyWeight);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct Newaccount {
    pub creator: Name,
    pub name: Name,
    pub owner: Authority,
    pub active: Authority,
}
impl_try_from_str!(Newaccount);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct PermissionLevel {
    pub actor: Name,
    pub permission: Name,
}
impl_try_from_str!(PermissionLevel);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct PermissionLevelWeight {
    pub permission: PermissionLevel,
    pub weight: Uint16,
}
impl_try_from_str!(PermissionLevelWeight);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct WaitWeight {
    pub wait_sec: Uint32,
    pub weight: Uint16,
}
impl_try_from_str!(WaitWeight);


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_str_for_buy_ram_bytes_success() {
        let input_string = r#"{"payer": "payer", "receiver": "receiver", "bytes": 123456}"#;
        let expected = Buyrambytes {
            payer: "payer".to_string(),
            receiver: "receiver".to_string(),
            bytes: 123456,
        };

        let result = Buyrambytes::try_from(input_string);

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), expected);
    }

    #[test]
    fn test_from_str_for_buy_ram_bytes_failure() {
        let input_string = "not a valid json string";

        let result = Buyrambytes::try_from(input_string);

        assert!(result.is_err());
        assert_eq!(result.unwrap_err().to_string(), "expected ident at line 1 column 2");
    }

    #[test]
    fn test_from_str_for_new_account() {
        let valid_json_string = r#"{
            "creator": "creator",
            "name": "newaccount",
            "owner": {
                "threshold": 1,
                "keys": [
                    {
                        "key": "EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV",
                        "weight": 1
                    }
                ],
                "accounts": [],
                "waits": []
            },
            "active": {
                "threshold": 1,
                "keys": [
                    {
                        "key": "EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV",
                        "weight": 1
                    }
                ],
                "accounts": [],
                "waits": []
            }
        }"#;
        let expected_result = Newaccount {
            creator: "creator".to_string(),
            name: "newaccount".to_string(),
            owner: Authority {
                threshold: 1,
                keys: vec![KeyWeight {
                    key: "EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV".to_string(),
                    weight: 1,
                }],
                accounts: vec![],
                waits: vec![],
            },
            active: Authority {
                threshold: 1,
                keys: vec![KeyWeight {
                    key: "EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV".to_string(),
                    weight: 1,
                }],
                accounts: vec![],
                waits: vec![],
            },
        };
        let result = Newaccount::try_from(valid_json_string).unwrap();
        assert_eq!(expected_result, result);

    }

    #[test]
    fn test_from_str_for_new_account_failure() {

        let invalid_json_string = "{}";
        let result = Newaccount::try_from(invalid_json_string);
        assert!(result.is_err());

        let invalid_json_string = r#"{"creator": "creator"}"#;
        let result = Newaccount::try_from(invalid_json_string);
        assert!(result.is_err());

        let invalid_json_string = "just some text";
        let result = Newaccount::try_from(invalid_json_string);
        assert!(result.is_err());
    }
}
